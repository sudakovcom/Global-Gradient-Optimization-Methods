\section{Глобальная одномерная оптимизация}
Алгоритм поиска глобального минимума функции вдоль одного направления будет основываться на интервальном анализе. Приведем основные определения и теоремы, которые нам пригодятся для посторения алгоритма.

\begin{definition*}
Интервалом $[a, b]$ называется следующее множество:
$$[a,b]:=\{x \in \mathbb{R} | a \le x \le b\}$$

в других обозначениях:
$$\bold{x}:=[\bold{\underline{x}},\bold{\overline{x}}]$$где $\bold{\underline{x}},\bold{\overline{x}}$ - левая и правая граница интервала соответственно.
\end{definition*}

\textbf{Арифметические свойства интервалов.}
\begin{itemize}

    \item $\bold{x} + \bold{y} = [{\bold{\underline{x}} + \bold{\underline{y}},  \bold{\overline{x}} + \bold{\overline{y}}}]$

    \item $\bold{x} - \bold{y} = [{\bold{\underline{x}} - \bold{\overline{y}},  \bold{\overline{x}} - \bold{\underline{y}}}]$

    \item $\bold{x} \cdot \bold{y} = [min(\bold{\underline{x} \underline{y}}, \bold{\underline{x} \overline{y}}, \bold{\overline{x} \underline{y}}, \bold{\overline{x} \overline{y}}) , max(\bold{\underline{x} \underline{y}}, \bold{\underline{x} \overline{y}}, \bold{\overline{x} \underline{y}}, \bold{\overline{x} \overline{y}})]$

    \item $\bold{x} / \bold{y} = \bold{x} \cdot[1/\bold{\overline{y}}, 1/\bold{\underline{y}}]$, если $\bold{\underline{y}} > 0$
\end{itemize}

\begin{example*}
Пусть известно, что первый гонщик проезжает длину гонки за время от 80 до 100 минут, а второй от 85 до 90 минут, какая может быть разница во времени приезда к финишу?

Воспользуемся вторым арифметическим свойством:

$\bold{T_1} = [80, 100]$

$\bold{T_2} = [85, 90]$, тогда результатом будет интервал $\bold{T_1} - \bold{T_2} = [80-90, 100-85] = [-10, 15]$

То есть первый гонщик может как приехать на 10 минут раньше, так и задержаться на 15 минут.
\end{example*}

\begin{remark*}
Так как интервалы являются множествами, то для них можно определить частичный порядок относительно включения:

$$\bold{a} \subseteq \bold{b} \iff \bold{\underline{b}} \leq \bold{\underline{a}} \cap \bold{\overline{a}} \leq \bold{\underline{b}}$$

\end{remark*}

\begin{property*}
Интервалы обладают свойством монотонности относительно арифметических операций:

Пусть $\bold{a} \subseteq \bold{a'}, \bold{b} \subseteq \bold{b'}, \star \subseteq \{+, -, \cdot, /\}$, тогда $\bold{a} \star \bold{b} \subseteq \bold{a'} \star \bold{b'}$
\end{property*}

\begin{theorem*}{Основная теорема интервальной арифметики}\\
Пусть $f(x_1, ..., x_n)$ - функция вещественных аргументов $x_1, ..., x_n$, и для нее определен результат $\bold{F(X_1, ..., X_n)}$ подстановки вместо аргументов интервалов которые они пробегают $\bold{(X_1, ..., X_n)} \subset \mathbb{IR}^n$ и для $\bold{(X_1, ..., X_n)}$ операциии выполняются по правилам интервальной арифметики. Тогда выполнено следущее:
    \begin{gather*}
        \{f(x_1,...,x_n) | x_1 \in \bold{X_1},...,x_n \in \bold{X_n}\} \subseteq \bold{F(\bold{X_1},...,\bold{X_n}})
    \end{gather*}
\end{theorem*}


\begin{proposition*}
Пусть $f(x_1, ..., x_n)$ - функция вещественных аргументов $x_1, ..., x_n$, и $\bold{F(X_1, ..., X_n)}$ соответствующая ей интервальная функция, тогда выполняется монотонность по включению:\\
Пусть $\bold{X_1},...,\bold{X_n}$ и $\bold{Y_1},...,\bold{Y_n}$, такие что $\bold{X_1} \subseteq \bold{Y_1},...,\bold{X_n} \subseteq \bold{Y_n}$, тогда:
$$\bold{F(X_1, ..., X_n)} \subseteq \bold{F(Y_1, ..., Y_n)}$$
\end{proposition*}

\begin{definition*}
Пусть $N > 0$  натуральное число, тогда если $\langle S_0,..., S_{n-1} \rangle$ семейство непустых подмножеств множества $S$, тогда будем называть его покрытием внутри $S$. В частности, если обьединение $S_0,..., S_{n-1}$ равно $S$, тогда последовательность $\langle S_0,..., S_{n-1} \rangle$ является покрытием $S$.
\end{definition*}


\begin{theorem*}
Рассмотрим задачу глобальной оптимизации. Пусть $\langle B_0,..., B_{n-1} \rangle$ семейство множеств, содержащее глобальный минимум, такое что упорядочено по возрастанию нижней границы $\bold{F}(B_i)$ для $i=0, 1, 2,..., N-1$. Пусть $U$ наименьшее из верхних значений функции для подмножеств $\langle \bold{F}(B_0),..., \bold{F}(B_{n-1}) \rangle$. Тогда интервал $[lb(\bold{F}(B_0)), U]$ содержит глобальным минимум $\mu$.
\end{theorem*}

Используя данную теорию, напишем алгоритм поиска глобального минимума вдоль направления.

\subsection*{Алгоритм Moore-Skelboe}

\textbf{Реализация}\\

\begin{lstlisting}[language=Python]
def MooreSkelboe(func_index, index, a, b, p, e_d,
                 e_f):  # func_index(number of function in list of functions), index(index of direction),
    # a(left border), b(right border), p(current point), e_d(error of d), e_f(error of f)
    F = Functions[func_index * 2 + 1]
    interval_d = []
    for i in range(len(p)):
        interval_d.append(interval[p[i], p[i]])
    interval_d[index] = interval[a, b]

    interval_f = F(interval_d)
    set_of_intervals = [[interval_d, interval_f]]
    U = right(interval_f)
    w_f = right(interval_f) - left(interval_f)
    w_d = right(interval_d[index]) - left(interval_d[index])
    best_interval = set_of_intervals[0]
    while (w_d > e_d) | (w_f > e_f):
        set_of_intervals.pop(0)
        mid_p = mid(best_interval[0][index])
        interval_1 = best_interval[0].copy()
        interval_2 = best_interval[0].copy()
        interval_1[index] = interval[left(best_interval[0][index]), mid_p]
        interval_1_f = F(interval_1)
        interval_2[index] = interval[mid_p, right(best_interval[0][index])]
        interval_2_f = F(interval_2)
        U = min(U, right(interval_1_f))
        U = min(U, right(interval_2_f))

        for i in range(len(set_of_intervals)):
            if U < left(set_of_intervals[i][1]):
                set_of_intervals = set_of_intervals[:i]
                break

        val_1 = left(interval_1_f)
        val_2 = left(interval_2_f)

        if (len(set_of_intervals) == 0) or (val_1 > left(
                set_of_intervals[-1][1])):
            set_of_intervals.append([interval_1, interval_1_f])
        else:
            l = 0
            r = len(set_of_intervals) - 1
            while l < r:
                m = int((l + r) / 2)
                if left(set_of_intervals[m][1]) > val_1:
                    r = m
                else:
                    l = m + 1
            set_of_intervals.insert(l, [interval_1, interval_1_f])

        if val_2 > left(set_of_intervals[-1][1]):
            set_of_intervals.append([interval_2, interval_2_f])
        else:
            l = 0
            r = len(set_of_intervals) - 1
            while l < r:
                m = int((l + r) / 2)
                if left(set_of_intervals[m][1]) > val_2:
                    r = m
                else:
                    l = m + 1
            set_of_intervals.insert(l, [interval_2, interval_2_f])

        best_interval = set_of_intervals[0]
        w_f = right(best_interval[1]) - left(best_interval[1])
        w_d = right(best_interval[0][index]) - left(best_interval[0][index])

    best_point = []
    for i in range(len(p)):
        best_point.append(mid(best_interval[0][i]))

    return best_point
\end{lstlisting}


\textbf{Сложность}\\

На каждой итерации длина одного из интервалов в семейсмве интервалов делится на 2. Каждая итерация совершается за O(log(size)).
Для достижения точности $\delta$ потребуется $$\frac{\ln(\frac{|[a, b]|}{\delta})}{\ln(\Phi)} \approx 2\ln(\frac{|[a, b]|}{\delta})$$ итераций.